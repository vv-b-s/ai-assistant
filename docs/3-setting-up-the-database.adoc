
:imagesdir: img
:source-highlighter: coderay
:icons: font

== Setting up the database

If you have reached up to this part, then congratulations!
There's no turning back now, you are going to finish this or be doomed of the unsettling feeling of incompleteness! ðŸ˜±

But we all know that you are an achiever, and you will never let a book unfinished, right? RIGHT!

That's what I also thought.
Now let's delve into expanding our database, so it can handle all the LLM responses we throw at it.
To start off, we are heading a towards a model, that looks like this.

=== The full database in a diagram

image::database.png[align=center]

I know.
Tables are a bit more than what we saw in the component diagram, but now we're delving into the lower levels, where we
have to be precise if we want to get the best results.

=== Building the entities

.This image was totally "not" generated by AI.
image::what-are-we.png[align=center]

Let's get started!

. Extend the user model
+
[source, java]
----
@Getter
@Setter
@NoArgsConstructor
@Entity(name = "users")
public class User {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private long id;

    @Version
    private long version;

    public User(String firstName) {
        this.firstName = firstName;
    }

    public User(String firstName, String lastName, int age, int height, double weight, Gender gender, int recommendedCal) {
        this.firstName = firstName;
        this.lastName = lastName;
        this.age = age;
        this.height = height;
        this.weight = weight;
        this.gender = gender;
        this.recommendedCal = recommendedCal;
    }

    private String firstName;
    private String lastName;
    private int age;
    private int height;
    private double weight;

    @Enumerated(EnumType.STRING)
    private Gender gender;

    private int recommendedCal;
}
----
+
CAUTION: This might break your current database.
I recommend you to delete all existing tables and let Hibernate generate new ones.

. Next step is to add our `Meal` entity. It will store the information of all the meals the user has eaten.
+
[source, java]
----
@Entity
@Getter
@Setter
@NoArgsConstructor
public class Meal {

    public static final String DEFAULT_REVIEW_VALUE = "Computing...";

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private long id;

    @Version
    private long version;

    @ManyToMany(cascade = {
            CascadeType.MERGE,
            CascadeType.PERSIST
    })
    @JoinTable(name = "meal_consummed_foods",
            joinColumns = @JoinColumn(name = "food_id"),
            inverseJoinColumns = @JoinColumn(name = "amount_id"))
    private Set<FoodItemAmount> consumedFoods; <.>

    private ZonedDateTime timestamp;

    @ManyToOne
    private User user;

    @Column(columnDefinition = "TEXT") <.>
    private String review = DEFAULT_REVIEW_VALUE; <.>

    public Meal(User user, Set<FoodItemAmount> consumedFoods, ZonedDateTime timestamp) {
        this.user = user;
        this.consumedFoods = consumedFoods;
        this.timestamp = timestamp;
    }
}
----
<.> We want the consumed foods to be shared by all users, so that when a new user enters the same food and amount,
we can find it in our database.
<.> The review might be more than 255 characters, so we need to make the space for that column in the database.
<.> We initialize the review with this value, as the content is going to be generated by the LLM in a later stage

. Our next entity will be the `FoodItem`
+
[source, java]
----
@Entity
@Getter
@Setter
@NoArgsConstructor
public class FoodItem {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private long id;

    @Version
    private long version;

    private String name;

    @ManyToMany(cascade = {
            CascadeType.MERGE,
            CascadeType.PERSIST
    })
    @JoinTable(name = "food_item_nutrient",
            joinColumns = @JoinColumn(name = "food_id"),
            inverseJoinColumns = @JoinColumn(name = "nutrient_id"))
    private Set<Nutrient> nutrients = new HashSet<>(); <.>

    public FoodItem(String name) {
        this.name = name;
    }
}
----
<.> To prevent redundancy we are going to link the nutrients with the food items just like we did to the meal and the food amounts

. The `Nutrient` table should look like so:
+
[source, java]
----
@Entity
@Getter
@Setter
@NoArgsConstructor
public class Nutrient {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private long id;

    @Version
    private long version;

    private String name;

    @ManyToMany(mappedBy = "nutrients")
    private Set<FoodItem> foods;

    public Nutrient(String name) {
        this.name = name;
    }
}
----

. And finally our last table `FoodItemAmount` should take the following form
+
[source, java]
----
@Entity
@Getter
@Setter
@NoArgsConstructor
public class FoodItemAmount {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private long id;

    @Version
    private long version;

    private double amount;
    private String unit;
    private Integer calories;

    @ManyToOne
    private FoodItem foodItem;

    @ManyToMany(mappedBy = "consumedFoods")
    private Set<Meal> meal;

    public FoodItemAmount(FoodItem foodItem, double amount, String unit) {
        this.foodItem = foodItem;
        this.amount = amount;
        this.unit = unit;
    }
}
----

And that's it!
You can be creative and think of a better model or even extend it to have more data, but to keep this workshop quick and easy,
we will stick only to these models.
Now I'll live up to you to generate the repositories for each entity.
By now, you should be able to figure out how it's done.
After you're done, we can move to the next chapter to set up our endpoints.

TIP: To avoid copy-pasting `id` and `version` every time, maybe consider putting them in an abstract class?
Why didn't I think of such an idea... ðŸ¤¯