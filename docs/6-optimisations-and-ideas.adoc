
:imagesdir: img
:source-highlighter: coderay
:icons: font

== App optimisations and ideas

As mentioned earlier, we are closing up the end of our work shop and the goal of this chapter will wrap things up.
This does not necessarily mean that you have to stop here.
Get inspired! Think of ideas how you can extend or improve the functionality of this application, or how you can apply the
acquired knowledge in your current or future projects.

Without much further ado. Let's get to the final steps of completing our project.

=== Setting up Asynchronous calls to the LLM

As I mentioned in the earlier chapters, we were supposed to call the LLM asynchronously.
The reason for that is due to the slow responses that the LLM computes.
In a real world scenario, where LLMs are powered by powerful and expensive servers, this won't be such an issue,
but perhaps you might want to offload some of the computations that the user is not concerned to get right away.
In this section I am going to show you how this could be done, using Spring's `@Async` capabilities.

==== Enabling the `@Async` annotation

In order to run your code asynchronously, you simply need to place the `@org.springframework.scheduling.annotation.Asynchronus`
annotation on a public bean method that you want to make asynchronous.
Before you are able to do that, though, you will need to first enable those capabilities, so when your Spring application
boots up, it will scan and activate the methods, annotated with `@Async`.

To enable asynchronous invocations, simply create a configuration class in the config package.
I shall call mine `SpringAsyncConfiguration`.

[source, java]
----
import org.springframework.context.annotation.Configuration;
import org.springframework.scheduling.annotation.EnableAsync;

@Configuration
@EnableAsync
public class SpringAsyncConfiguration {

}
----

Now when you start up the application, Spring will know that all public methods annotated with `@Async` should be run asynchronously.

==== Making LLM calls asynchronous

TIP: Although this part is fairly easy, you might feel a bit struggle, making everything work in asynchronous order.
Don't let that discourage you. If you ever get stuck you can always use techniques such as logging, to help you out and see what's happening.

Right now we made our implementation so that all of our LLM calls are in one place only - in the `NutritionAdviserService`
If you dealt with asynchronous invocations before, you should already know that converting out `obtainMealDataFromLLM` method to this...

[source,java]
----

    public CompletableFuture<Void> obtainMealDataFromLLM(MealCreatedEvent event) {
        ...
        return CompletableFuture.completedFuture(null);
    }
----

...should be enough to run all the LLM calls asynchronously.

Although correct, this approach won't be good enough, because it will not run our LLM calls separately, but rather it will run them
sequentially, which is kind of not using all the available resources we have, to make this quicker.
One other issue is that with this approach we are constrained by Spring's design of running asynchronous methods meaning that:

* You can't call asynchronous methods if they are private
* You can't call asynchronous methods in the same class even if they are public
* You can only call one asynchronous method from a bean outside.

Since this is an event handler, we can make all the three LLM methods inside public and async, or there could be a simpler
approach. Let's make a helper class in the `utils` folder and call it `AsyncInvocationService`.

[source, java]
----
@Service
@RequiredArgsConstructor
public class AsyncInvocationService {

    @Async
    @Transactional(Transactional.TxType.REQUIRES_NEW) <.>
    public CompletableFuture<Void> run(Runnable procedure) {
        try {
            procedure.run(); <.>
            return CompletableFuture.completedFuture(null);
        } catch (Exception e) {
            //log the error
            throw new IllegalStateException("Failed to execute asynchronous task", e);
        }
    }
}
----

<.> Since all the invocations do modifications to the database and this call is asynchronous, we want to avoid any optimistic
locks due to running the action on a separate thread. To do so, we will tell Hibernate to start a new transaction here.
<.> All the code we want to run asynchronously will be executed at this point, leaving the main thread clean from the exceptional
time delays the LLM needs to compute its data.

Now when we go back to our `NutritionAdviserService`, we can make our `obtainMealDataFromLLM` method look like so:

[source, java]
----
    private final AsyncInvocationService async;

    ...

    @EventListener
    public void obtainMealDataFromLLM(MealCreatedEvent event) {
        Meal meal = event.getMeal();
        async.run(() -> obtainNutrientData(meal));
        async.run(() -> obtainCaloricData(meal));
        async.run(() -> obtainMealReview(meal));
    }
----

Pretty straightforward, right?

Now when you create a new meal, you'll most probably not see the additional data, such as meal review or caloric information
you used to see before, but on the other hand the task will complete in an instant.
If you wait for 1-2 minutes and try to get that information through the GET requests, though, you should eventually see those
results being generated right in front of your eyes.

=== Logging important application events

Adding asynchronous invocations can sometimes create quite a headache, as running the code on a separate thread,
prevents any errors form appearing in the application's log.
This can sometimes be a problem, as you are not able to tackle what is going on and why your actions have no outcome.
Debugging might also be difficult, as breakpoints can sometimes be missed by the IDE.
To help us out in this scenario, we will need to add logs to the most important places, where we feel like something might go wrong.

We just need to simply create one more class, called `LoggerConfiguration` in the `config` package.

[source, java]
----
@Configuration
public class LoggerConfiguration {

    @Bean
    public Logger producerLogger(InjectionPoint injectionPoint) {
        return Logger.getLogger(injectionPoint.getMember().getDeclaringClass().getName());
    }
}
----

This bean configuration class will autowire an instance of a Logger, wherever we need one.
 +
Here is one example:

[source, java]
----
@Service
@RequiredArgsConstructor
public class AsyncInvocationService {

    private final Logger log;

    @Async
    @Transactional(Transactional.TxType.REQUIRES_NEW)
    public CompletableFuture<Void> run(Runnable procedure) {
        try {
            procedure.run();
            return CompletableFuture.completedFuture(null);
        } catch (Exception e) {
            log.severe("Failed to execute asynchronous task: %s".formatted(e.getMessage()));
            throw new IllegalStateException("Failed to execute asynchronous task", e);
        }
    }
}
----

I will leave you to decide where are the important places to place your log messages and see how everything comes into action. ðŸ˜‰


=== Additional ideas to look far and beyond

Weâ€™ve reached the end of this workshop!

Following a guide is great, but you know what will really deepen your understanding? Getting your hands dirty.

Here are a few ideas to take this project further:

* Think of other areas where you can apply LLM computations.
* Extend the app with features you feel are missing.
* Experiment with new prompts to improve response quality.
* Try using different LLM models and compare the results.
* Integrate this idea into your own project.
* Research how to fine-tune an LLM for more topic-specific accuracy.

I truly hope you enjoyed this workshop and that it inspired you to build your own LLM-powered applications!
Letâ€™s aim for a future where AI and LLMs aren't seen as threats to our jobs, but as powerful tools that bridge the gap between vast knowledge and fast action.