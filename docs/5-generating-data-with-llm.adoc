
:imagesdir: img
:source-highlighter: coderay
:icons: font

== Generating data with LLM

We have finally reached the part where the magic happens!
In this section we are going to take the data we collected form the user and task our local AI to generate useful data
that is going to be presented to the user when they demand it.
Generally the user would be interested how did the meal impact their nutrition and what are the nutritional values of the foods they eat.
Let's see how we can incorporate our LLM integration to do this for us.

The first part is to create proper service classes that are going to give our LLM different tasks, based on the purpose
it is meant to do.

.But, before we begin
****
During this section, you might ask yourself: why not create an all-in-one AI prompt? ðŸ¤”
While it would be ideal to provide AI with a single prompt for comprehensive analysis, the more diverse the input we include,
the more varied and potentially unfocused the responses become.
That's why we want to concentrate on a single task at a time.

Based on the content of the system prompt, the LLM will generate a unique output, meaning that every
single word matters.
I embrace you to try different prompts and see what outcomes you will get.
Maybe your results might be better than the ones we shall observe in this workshop.
****

.Take it with a grain of salt!
[CAUTION]
====
* Please keep in mind that all the data generated by the LLM model is artificial and in most cases inaccurate!
* llama 3.2 does not have access to the internet, neither is trained to give accurate food advices.
* Remember that we use it only to prove the possibility to utilize an LLM model for these tasks.
* In the real world scenario you would need to specifically train your LLM with the data it needs to be sufficient nutrition
adviser.
====

=== The `NutrientGenerator`, our first LLM generator

The nutrient generator's task is to create nutrient data for our foods.
If you remember we did not do anything for the Nutrient entity in our previous chapters.
This is the place where we are finally going to do something about it.
Inside your `ai` package, create a class called `NutrientGenerator` and add the following implementation:

[source, java]
----
@Service
@RequiredArgsConstructor
class NutrientGenerator {

    record FoodItemNutrients(String name, List<String> nutrients) {
    }

    private static final String PROMPT = """ <.>
            You're a helpful assistant. You are going to be given a list of foods.
            In return you have to respond with a json formatted list of the nutrients associated with that food.
            For example:
            ----
            User: Banana, Pistachio, Cheese
            AI: [
                    {
                        "name": "Banana",
                        "nutrients": ["Vitamin C", "Vitamin B6", "Fiber", "Potassium", "Protein", "Magnesium", "Manganese", "Saturated fat"]
                    },
                    {
                        "name": "Pistachio",
                        "nutrients": ["Dietary fiber", "Protein", "G carbohydrate", "Vitamin B6", "Copper", "Iron", "Magnesium", "Phosphorus", "Manganese"]
                    },
                    {
                        "name": "Cheese",
                        "nutrients": ["Calcium", "Vitamin B12", "Phosphorus", "Sodium", "Vitamin A", "Phosphorus", "Potassium"]
                    }
            ]

            ----

            Do not limit yourself to the list given above. Answer with as many nutrients as you know. If you don't recognize the food item, set the nutrients value to null.


            For example:
            ----
            User: Banana, Facebook, Cheese
            AI: [
                    {
                        "name": "Banana",
                        "nutrients": ["Vitamin C", "Vitamin B6", "Fiber", "Potassium", "Protein", "Magnesium", "Manganese", "Saturated fat"]
                    },
                    {
                        "name": "Facebook",
                        "nutrients": null
                    },
                    {
                        "name": "Cheese",
                        "nutrients": ["Calcium", "Vitamin B12", "Phosphorus", "Sodium", "Vitamin A", "Phosphorus", "Potassium"]
                    }
            ]
            ----

            Please answer only in the format shown in "----". Do not add anything else to your answer.
            """;

    private final OllamaAiService ollamaAiService;


    public Map<FoodItem, List<String>> obtainNutrientData(Collection<FoodItem> foodItems) {
        Map<String, FoodItem> reverseMap = foodItems.stream().collect(Collectors.toMap(FoodItem::getName, fi -> fi));

        String foodList = String.join(", ", reverseMap.keySet());
        String aiOutput = ollamaAiService.call(PROMPT, foodList);

        Map<FoodItem, List<String>> result = new HashMap<>();
        try {
            FoodItemNutrients[] foodNutrientResult = JsonUtils.toObject(aiOutput, FoodItemNutrients[].class);
            for (var item : foodNutrientResult) {
                FoodItem foodItem = reverseMap.get(item.name);
                result.putIfAbsent(foodItem, item.nutrients);
            }

            return result;
        } catch (JsonProcessingException jpe) {
            //handle the exception
        }
    }
}
----
<.> The prompt should be consistent and exact.
You need to specify exactly what you want the LLM to do, otherwise the results might not be predictable.

NOTE: Throughout the implementation of the generators, we are not going to produce or modify any of the entities.
This is a task that should be performed elsewhere, as we might need to validate the data or do something else with it,
before we persist it.

Now we want to test if our generator works properly.
To do so, we have to connect it to our meal controller.

In the `ai` package create another class, called `NutritionAdviserService`.
This will be our single entrypoint to the LLM generators:

[source, java]
----
@Service
@RequiredArgsConstructor
public class NutritionAdviserService {

    @EventListener <.>
    public void obtainMealDataFromLLM(MealCreatedEvent event) { <.>

    }
}
----
<.> We want this class to handle application events, as we are going to call this after the creation of the meal,
but not invoke it directly into the controller.
This design allows us to add different event handlers in the future, where we can trigger separate tasks
and not mix everything into one single service.
<.> The event payload needs specific implementation in order to be injected into the method.
You can implement it like this:
+
[source, java]
----
@Getter
public class MealCreatedEvent extends ApplicationEvent {

    private final Meal meal;

    public MealCreatedEvent(Meal meal, Object source) {
        super(source);
        this.meal = meal;
    }
}
----

The next step is to implement logic for invoking the Nutrient generator:

[source, java]
----
public class NutritionAdviserService {

    //Injections

    @EventListener
    public void obtainMealDataFromLLM(MealCreatedEvent event) {
        Meal meal = event.getMeal();
        obtainNutrientData(meal);
    }

    private void obtainNutrientData(Meal meal) {
        List<FoodItem> foodItemsWithoutNutrients = meal.getConsumedFoods().stream()
                .map(FoodItemAmount::getFoodItem)
                .filter(foodItem -> foodItem.getNutrients().isEmpty()).toList();

        if (foodItemsWithoutNutrients.isEmpty()) { <.>
            return;
        }

        Map<FoodItem, List<String>> foodNutrients = nutrientGenerator.obtainNutrientData(foodItemsWithoutNutrients);

        //Finding or creating new nutrient entries, to avoid duplication in the database
        Map<String, Nutrient> nutrientMap = computeNutrientMap(foodNutrients.values()
                .stream().flatMap(List::stream).collect(Collectors.toSet()));

        for (var entry : foodNutrients.entrySet()) {
            FoodItem foodItem = entry.getKey();
            List<String> generatedNutrients = entry.getValue();
            if (generatedNutrients != null) {
                List<Nutrient> nutrients = generatedNutrients.stream().map(nutrientMap::get).toList();
                foodItem.getNutrients().addAll(nutrients);
                foodItemRepository.save(foodItem);
            }
        }
    }
}

 private Map<String, Nutrient> computeNutrientMap(Set<String> nutrientNames) {
        Map<String, Nutrient> nutrientMap = new HashMap<>();
        for (var name : nutrientNames) {
            Nutrient nutrient = nutrientRepository.findByName(name)
                    .orElseGet(() -> nutrientRepository.save(new Nutrient(name)));
            nutrientMap.put(name, nutrient);
        }

        return nutrientMap;
    }
----

The code should be self-explanatory - we filter out the food items that already have nutritional data and leave only the
data that needs to be processed by the LLM.
Then after we get response from the LLM, we flatten the data to create unique `Nutrient` entities and avoid persisting ones that already exist.
Finally, we assign the list of nutrients to each food, found in the output list.

Now in order to call this event and trigger the logic, we need to go back to the `MealController` and add the event invocation:

[source, java]
----
...
public class MealController {
    private final ApplicationEventPublisher event;

    ...

    @PostMapping("/user/{id}")
    public ResponseEntity<MealDto> createMeal(@PathVariable("id") Long userId, @RequestBody MealDto mealDto) {
        ...

        event.publishEvent(new MealCreatedEvent(meal, this)); <.>
        return ResponseEntity.ok(new MealDto(meal));
    }

    public ResponseEntity<List<MealDto>> listAllUserMeals(@PathVariable("id") Long userId) {...}

}
----
<.> Put your event trigger right before sending the response

Now with this done, you can test the POST `/meal/user/{id}` endpoint again.
Your response might be delayed for up to a minute.
LLM is thinking!

Once you see a response from the service, you will not immediately see any nutrients.
This is because we have not programmed the DTO to show them.
But we have another endpoint for that.
Simply call GET `/food/search?name=<foodName>`, and check if the food has a list of nutrients assigned.
If you have implemented the classes properly, you should see a result like this:

[source, json]
----
[
  {
        "id": 3,
        "name": "Cheese",
        "nutrients": [
            "Vitamin B12",
            "Phosphorus",
            "Cholesterol",
            "Vitamin A",
            "Calcium",
            "Sodium"
        ]
    }
]
----

.Duude... It's so slow...
[WARNING]
====
From now on things, are going to get a little bit slower, I know.
Depending on how your machine is performing, you might experience slowdowns,
lags and thermal increases, but don't worry and load that patience up!
We are going to mitigate this in the next chapter, by making those invocations asynchronous.

This won't necessarily fix the computational speed, but at least it is going to improve the user experience
by avoiding the wait for AI computation.
====

=== `CaloricInformationGenerator`

The next thing we don't have data for is how many calories does each `FoodItemAmount` have.
To be able to get that information, we will need to implement yet another LLM prompting class, called `CaloricInformationGemarator`
(or whatever better naming you have to offer...)

[source, java]
----
@Service
@RequiredArgsConstructor
class CaloricInformationGenerator {

    record FoodCaloricImpact(String name, int calories) {
    }

    private static final String PROMPT = """
            You're a helpful assistant. You are going to be given a list of foods and their amounts.
            In return you have to respond with a json formatted list of the name of the food, its amount and its caloric impact, based on the amount given.
            For example:
            ----
            User: 500 gr Banana, 100 gr Pistachio, 1 slice Cheese
            AI: [
                    {
                        "name": "500 gr Banana",
                        "calories": "445"
                    },
                    {
                        "name": "100 gr Pistachio",
                        "calories": 560
                    },
                    {
                        "name": "1 slice Cheese",
                        "calories": 40
                    }
            ]

            ----

            Do not limit yourself to the list given above. You may receive the same food item in different amounts.
            Give an answer for each ane every amount set. Calories will be integers only.
            If you don't recognize the food item, or the amount unit or size, set the caloric value to null.


            For example:
            ----
            User: 500 gr Banana, 100 gr Pistachio, 1 click Facebook
            AI: [
                    {
                        "name": "500 gr Banana",
                        "calories": "445"
                    },
                    {
                        "name": "100 gr Pistachio",
                        "calories": 560
                    },
                    {
                        "name": "1 click Facebook",
                        "calories": null
                    }
            ]
            ----

            Please answer only in the format shown in "----". Do not add anything else to your answer.
            """;

    private final OllamaAiService ollamaAiService;

    public Map<FoodItemAmount, Integer> computeCaloricInformation(Collection<FoodItemAmount> foodItemAmounts) {
        Map<String, FoodItemAmount> amountDataInput = new HashMap<>();
        for (var foodItemAmount : foodItemAmounts) {
            String listItem = "%f %s %s".formatted(foodItemAmount.getAmount(), foodItemAmount.getUnit(),
                    foodItemAmount.getFoodItem().getName());
            amountDataInput.put(listItem, foodItemAmount);
        }

        String inputList = String.join(", ", amountDataInput.keySet());
        String generatedResponse = ollamaAiService.call(PROMPT, inputList);
        try {
            FoodCaloricImpact[] parsedResults = JsonUtils.toObject(generatedResponse, FoodCaloricImpact[].class);

            //We don't want to implicitly set the data to the entity here. It should be done in a safe place where database
            //relations are managed.
            Map<FoodItemAmount, Integer> computedCalories = new HashMap<>();
            for (var result : parsedResults) {
                FoodItemAmount foodItemAmount = amountDataInput.get(result.name);
                computedCalories.put(foodItemAmount, result.calories);
            }

            return computedCalories;
        } catch (JsonProcessingException jpe) {
            //handle the exception
        }
    }
}

----

Again, we use a similar pattern, as it is proven to work with our previous prompter.
We will avoid doing anything to the data at this point and move onto the `NutritionAdviserService` where the processing will be done.

[source, java]
----
public class NutritionAdviserService {

    ...
    @EventListener
    public void obtainMealDataFromLLM(MealCreatedEvent event) {
        ...
        obtainCaloricData(meal);
    }

    private void obtainCaloricData(Meal meal) {
        List<FoodItemAmount> foodAmountsWithoutCaloricData = meal.getConsumedFoods()
                .stream().filter(fia -> fia.getCalories() == null).toList();

        if (foodAmountsWithoutCaloricData.isEmpty()) {
            return;
        }

        Map<FoodItemAmount, Integer> obtainedCaloricInformation = caloricInformationGenerator
                .computeCaloricInformation(foodAmountsWithoutCaloricData);

        for (var entry : obtainedCaloricInformation.entrySet()) {
            FoodItemAmount foodItemAmount = entry.getKey();
            foodItemAmount.setCalories(entry.getValue());
            foodItemAmountRepository.save(foodItemAmount);
        }
    }

    ...
}
----

Once more we check only for the `FoodItemAmount` entities that don't have computed caloric data
and task the LLM to generate that information for us.
You can go on and test again.
Currently, you should be able to see the generated data right into the response, but when we make this asunchronous,
we have to query our meal by id after a couple of minutes, to observe if any values got updated.

=== `MealReviewGenerator`

What is a nutrition adviser without the most important to the user piece of data?
The meal review - it is going to give the user some takeaways (no pun intended) of what the LLM thinks about the user's meal.
To create that, let's implement the `MealReviewGenerator` class:

[source, java]
----
@Service
@RequiredArgsConstructor
class MealReviewGenerator {

    record MealAIInput(int age, String gender, String height, String weight, int dailyKcal, List<String> meal) {
    }

    private static final String PROMPT = """
            You are a helpful assistant.
            You will receive a json object, containing information about a user, consisting of their age, gender, height, weight and recommended daily caloric intake.
            Inside that json you will get a list of food items this person ate on a single meal, along with the amounts of the food they ate.
            Your ultimate goal is to do a breakdown of that meal and advice the user whether this meal was ideal for them and whether it should be improved next time.

            Here is an example:
            ----
            User: {
                "age": 15,
                "gender": MALE,
                "height": "165 cm",
                "weight": "56.8 kg",
                "dailyKcal": 2200,
                "meal": [
                    "100 gr banana",
                    "400 gr greek yogurt",
                    "100 gr bread",
                    "10 gr blueberries",
                    "10 gr peanut butter",
                    "2 whole eggs"

                ]
            }

            AI:
            Your meal is well-balanced overall, especially for someone with a daily intake of 2200 kcal. Here's a breakdown of how it aligns with your nutritional needs:
            Pros:

                High Protein (83.6 g):
                    Excellent for muscle repair and growth, especially for a 15-year-old male in a growth phase. It covers ~38% of your daily protein needs (recommended ~1.2-2.0 g/kg of body weight).
                Good Balance of Carbs (92.3 g):
                    Provides quick energy for physical and mental activities. ~42% of the meal's calories come from carbs, which is within the acceptable range.
                Healthy Fats (33.5 g):
                    Includes healthy fats from peanut butter and eggs, supporting hormone production and overall health. Fat contributes ~30% of this mealâ€™s calories, a good ratio.
                Micronutrients:
                    Banana: Rich in potassium.
                    Blueberries: Antioxidants for overall health.
                    Eggs: High in B vitamins, choline, and selenium.
                    Greek Yogurt: Calcium and probiotics for bone and gut health.

            Cons/Improvements:

                Low Fiber:
                    Only ~6-7 g of fiber in this meal (ideal daily target: ~25-30 g). Adding whole grains (like whole wheat bread) or more fruits/veggies would help.
                High Saturated Fat from Eggs and Peanut Butter:
                    Saturated fat is fine in moderation, but with 5 large eggs, itâ€™s a bit high (~10 g). Reducing to 2-3 eggs or adding egg whites could lower saturated fat without compromising protein.
                Low Veggies:
                    No vegetables in the meal. Adding spinach, tomatoes, or bell peppers would boost vitamins A, C, and fiber.
                Sodium (Potentially High):
                    Depending on the bread and yogurt, sodium could be high. Opt for low-sodium options.

            Suggestions to Improve:

                Replace Some Eggs with Egg Whites:
                    Use 3 whole eggs + 2-3 egg whites to maintain protein but reduce calories and saturated fat.
                Swap Bread for Whole Grain/Seeded Bread:
                    Increases fiber and micronutrients like magnesium and zinc.
                Increase Vegetables:
                    Add 100-200 g of sautÃ©ed or fresh veggies (spinach, mushrooms, peppers) to the eggs.
                Include Healthy Fats:
                    Instead of peanut butter, try avocado for healthier monounsaturated fats.

            How Good Is This Meal?

            8/10: Itâ€™s an excellent high-protein, well-rounded meal, especially for a post-workout or breakfast. With small adjustments (e.g., more veggies, fiber, and balanced fats), it can become even healthier while maintaining its convenience and flavor!

            ----

            Please answer only in the format I gave you within the "----".
            """;

    private final OllamaAiService ollamaAiService;

    public String generateMealAnalysis(Meal meal) {
        User user = meal.getUser();
        String height = "%d cm".formatted(user.getHeight());
        String weight = "%f kg".formatted(user.getWeight());
        String gender = user.getGender().toString();

        List<String> consumedFoods = meal.getConsumedFoods()
                .stream().map(fia -> "%f %s %s".formatted(fia.getAmount(), fia.getUnit(), fia.getFoodItem().getName()))
                .toList();

        MealAIInput aiInput = new MealAIInput(user.getAge(), gender, height, weight, user.getRecommendedCal(), consumedFoods);

        try {
            String userInput = JsonUtils.toJson(aiInput);

            //We are not updating meal entity here, as we want to do it safely outside of this class.
            return ollamaAiService.call(PROMPT, userInput);
        } catch (JsonProcessingException jpe) {
            //process the exception
        }
    }
}
----

This one is a bit longer for prompting and will take longer for the LLM to generate a response.
As we want more freely given information and ask the LLM for broader opinion, this will involve more time for it to "reason".

Finally, we are going to add invocation in our `NutritionAdviserService`

[source, java]
----
public class NutritionAdviserService {

    //definitions

    @EventListener
    public void obtainMealDataFromLLM(MealCreatedEvent event) {
        Meal meal = event.getMeal();
        obtainNutrientData(meal);
        obtainCaloricData(meal);
        obtainMealReview(meal); //I am here
    }

    ...

    private void obtainMealReview(Meal meal) {
        if (!meal.getReview().equals(Meal.DEFAULT_REVIEW_VALUE)) {
            return;
        }

        String review = mealReviewGenerator.generateMealAnalysis(meal);
        meal.setReview(review);
        mealRepository.save(meal);
    }
}
----

This one is the easiest to update, as it does not require any processing whatsoever.
We take the AI response as-is and update the `review` column of our `Meal` table.
To test this, just like we did for the caloric intake, simply create a new meal.
After a couple of minutes, you should get all the information, including caloric impact and review.

=== Conclusion

If you reached the end of this chapter, then congratulations!
You have successfully created your small nutrition adviser app with the ability to use LLM for making more advanced decisions quicker.
If you enjoyed this part, please keep it up and stay with the next final chapter, where we are going to implement some asynchronous
operations that will allow us to have a smoother user experience and give you some ideas what you can do to improve the application,
while exploring every part of it.